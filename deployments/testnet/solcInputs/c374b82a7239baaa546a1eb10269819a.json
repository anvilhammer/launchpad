{
  "language": "Solidity",
  "sources": {
    "contracts/Access/MISOAccessControls.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.6.12;\n\nimport \"./MISOAdminAccess.sol\";\n\n/**\n * @notice Access Controls\n * @author Attr: BlockRocket.tech\n */\ncontract MISOAccessControls is MISOAdminAccess {\n    /// @notice Role definitions\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant SMART_CONTRACT_ROLE = keccak256(\"SMART_CONTRACT_ROLE\");\n    bytes32 public constant OPERATOR_ROLE = keccak256(\"OPERATOR_ROLE\");\n    bytes32 public constant USER_ROLE = keccak256(\"USER_ROLE\");\n\n    /**\n     * @notice The deployer is automatically given the admin role which will allow them to then grant roles to other addresses\n     */\n    constructor() public {\n    }\n\n\n    /////////////\n    // Lookups //\n    /////////////\n\n    /**\n     * @notice Used to check whether an address has the minter role\n     * @param _address EOA or contract being checked\n     * @return bool True if the account has the role or false if it does not\n     */\n    function hasMinterRole(address _address) public view returns (bool) {\n        return hasRole(MINTER_ROLE, _address);\n    }\n\n    function hasUserRole(address _address) public view returns (bool) {\n        return hasRole(USER_ROLE, _address);\n    }\n\n    /**\n     * @notice Used to check whether an address has the smart contract role\n     * @param _address EOA or contract being checked\n     * @return bool True if the account has the role or false if it does not\n     */\n    function hasSmartContractRole(address _address) public view returns (bool) {\n        return hasRole(SMART_CONTRACT_ROLE, _address);\n    }\n\n    /**\n     * @notice Used to check whether an address has the operator role\n     * @param _address EOA or contract being checked\n     * @return bool True if the account has the role or false if it does not\n     */\n    function hasOperatorRole(address _address) public view returns (bool) {\n        return hasRole(OPERATOR_ROLE, _address);\n    }\n\n    ///////////////\n    // Modifiers //\n    ///////////////\n\n    /**\n     * @notice Grants the minter role to an address\n     * @dev The sender must have the admin role\n     * @param _address EOA or contract receiving the new role\n     */\n    function addMinterRole(address _address) external {\n        grantRole(MINTER_ROLE, _address);\n    }\n\n    function addUserRole(address _address) external {\n        grantRole(USER_ROLE, _address);\n    }\n\n    /**\n     * @notice Removes the minter role from an address\n     * @dev The sender must have the admin role\n     * @param _address EOA or contract affected\n     */\n    function removeMinterRole(address _address) external {\n        revokeRole(MINTER_ROLE, _address);\n    }\n\n    /**\n     * @notice Grants the smart contract role to an address\n     * @dev The sender must have the admin role\n     * @param _address EOA or contract receiving the new role\n     */\n    function addSmartContractRole(address _address) external {\n        grantRole(SMART_CONTRACT_ROLE, _address);\n    }\n\n    /**\n     * @notice Removes the smart contract role from an address\n     * @dev The sender must have the admin role\n     * @param _address EOA or contract affected\n     */\n    function removeSmartContractRole(address _address) external {\n        revokeRole(SMART_CONTRACT_ROLE, _address);\n    }\n\n    /**\n     * @notice Grants the operator role to an address\n     * @dev The sender must have the admin role\n     * @param _address EOA or contract receiving the new role\n     */\n    function addOperatorRole(address _address) external {\n        grantRole(OPERATOR_ROLE, _address);\n    }\n\n    /**\n     * @notice Removes the operator role from an address\n     * @dev The sender must have the admin role\n     * @param _address EOA or contract affected\n     */\n    function removeOperatorRole(address _address) external {\n        revokeRole(OPERATOR_ROLE, _address);\n    }\n\n}\n"
    },
    "contracts/Access/MISOAdminAccess.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.6.12;\n\nimport \"../OpenZeppelin/access/AccessControl.sol\";\n\n\ncontract MISOAdminAccess is AccessControl {\n\n    /// @dev Whether access is initialised.\n    bool private initAccess;\n\n    /// @notice The deployer is automatically given the admin role which will allow them to then grant roles to other addresses.\n    constructor() public {\n    }\n\n    /**\n     * @notice Initializes access controls.\n     * @param _admin Admins address.\n     */\n    function initAccessControls(address _admin) public {\n        require(!initAccess, \"Already initialised\");\n        require(_admin != address(0), \"Incorrect input\");\n        _setupRole(DEFAULT_ADMIN_ROLE, _admin);\n        initAccess = true;\n    }\n\n    /////////////\n    // Lookups //\n    /////////////\n\n    /**\n     * @notice Used to check whether an address has the admin role.\n     * @param _address EOA or contract being checked.\n     * @return bool True if the account has the role or false if it does not.\n     */\n    function hasAdminRole(address _address) public  view returns (bool) {\n        return hasRole(DEFAULT_ADMIN_ROLE, _address);\n    }\n\n    ///////////////\n    // Modifiers //\n    ///////////////\n\n    /**\n     * @notice Grants the admin role to an address.\n     * @dev The sender must have the admin role.\n     * @param _address EOA or contract receiving the new role.\n     */\n    function addAdminRole(address _address) external {\n        grantRole(DEFAULT_ADMIN_ROLE, _address);\n    }\n\n    /**\n     * @notice Removes the admin role from an address.\n     * @dev The sender must have the admin role.\n     * @param _address EOA or contract affected.\n     */\n    function removeAdminRole(address _address) external {\n        revokeRole(DEFAULT_ADMIN_ROLE, _address);\n    }\n}\n"
    },
    "contracts/OpenZeppelin/access/AccessControl.sol": {
      "content": "pragma solidity 0.6.12;\n\nimport \"../utils/EnumerableSet.sol\";\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    struct RoleData {\n        EnumerableSet.AddressSet members;\n        bytes32 adminRole;\n    }\n\n    mapping (bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view returns (bool) {\n        return _roles[role].members.contains(account);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\n        return _roles[role].members.length();\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\n        return _roles[role].members.at(index);\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to grant\");\n\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to revoke\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);\n        _roles[role].adminRole = adminRole;\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (_roles[role].members.add(account)) {\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (_roles[role].members.remove(account)) {\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "contracts/OpenZeppelin/utils/EnumerableSet.sol": {
      "content": "\npragma solidity 0.6.12;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "contracts/OpenZeppelin/utils/Context.sol": {
      "content": "\n\npragma solidity 0.6.12;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "contracts/MISOMarket.sol": {
      "content": "pragma solidity 0.6.12;\n\n//----------------------------------------------------------------------------------\n//    I n s t a n t\n//\n//        .:mmm.         .:mmm:.       .ii.  .:SSSSSSSSSSSSS.     .oOOOOOOOOOOOo.  \n//      .mMM'':Mm.     .:MM'':Mm:.     .II:  :SSs..........     .oOO'''''''''''OOo.\n//    .:Mm'   ':Mm.   .:Mm'   'MM:.    .II:  'sSSSSSSSSSSSSS:.  :OO.           .OO:\n//  .'mMm'     ':MM:.:MMm'     ':MM:.  .II:  .:...........:SS.  'OOo:.........:oOO'\n//  'mMm'        ':MMmm'         'mMm:  II:  'sSSSSSSSSSSSSS'     'oOOOOOOOOOOOO'  \n//\n//----------------------------------------------------------------------------------\n//\n// Chef Gonpachi's MISO Marketplace\n//\n// A factory to conveniently deploy your own source code verified auctions\n//\n// Inspired by Bokky's EtherVendingMachince.io\n// https://github.com/bokkypoobah/FixedSupplyTokenFactory\n// \n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// The above copyright notice and this permission notice shall be included \n// in all copies or substantial portions of the Software.\n//\n// Made for Sushi.com \n// \n// Enjoy. (c) Chef Gonpachi 2021 \n// <https://github.com/chefgonpachi/MISO/>\n//\n// ---------------------------------------------------------------------\n// SPDX-License-Identifier: GPL-3.0                        \n// ---------------------------------------------------------------------\n\nimport \"./Access/MISOAccessControls.sol\";\nimport \"./Utils/BoringMath.sol\";\nimport \"./Utils/SafeTransfer.sol\";\nimport \"./interfaces/IMisoMarket.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./interfaces/IBentoBoxFactory.sol\";\nimport \"./OpenZeppelin/token/ERC20/SafeERC20.sol\";\n\n\n\ncontract MISOMarket is SafeTransfer {\n\n    using BoringMath for uint256;\n    using BoringMath128 for uint128;\n    using BoringMath64 for uint64;\n    using SafeERC20 for IERC20;\n\n    /// @notice Responsible for access rights to the contract.\n    MISOAccessControls public accessControls;\n    bytes32 public constant MARKET_MINTER_ROLE = keccak256(\"MARKET_MINTER_ROLE\");\n\n    /// @notice Whether market has been initialized or not.\n    bool private initialised;\n\n    /// @notice Struct to track Auction template.\n    struct Auction {\n        bool exists;\n        uint64 templateId;\n        uint128 index;\n    }\n\n    /// @notice Auctions created using factory.\n    address[] public auctions;\n\n    uint256 public auctionsLength = 0;\n\n    /// @notice Template id to track respective auction template.\n    uint256 public auctionTemplateId;\n\n    IBentoBoxFactory public bentoBox;\n\n    /// @notice Mapping from market template id to market template address.\n    mapping(uint256 => address) private auctionTemplates;\n\n    /// @notice Mapping from market template address to market template id.\n    mapping(address => uint256) private auctionTemplateToId;\n\n    // /// @notice mapping from template type to template id\n    mapping(uint256 => uint256) public currentTemplateId;\n\n    /// @notice Mapping from auction created through this contract to Auction struct.\n    mapping(address => Auction) public auctionInfo;\n\n    /// @notice Struct to define fees.\n    struct MarketFees {\n        uint128 minimumFee;\n        uint32 integratorFeePct;\n    }\n\n    /// @notice Minimum fee to create a farm through the factory.\n    MarketFees public marketFees;\n\n    /// @notice Contract locked status. If locked, only minters can deploy\n    bool public locked;\n\n    ///@notice Any donations if set are sent here.\n    address payable public misoDiv;\n\n    ///@notice Event emitted when first initializing the Market factory.\n    event MisoInitMarket(address sender);\n\n    /// @notice Event emitted when template is added to factory.\n    event AuctionTemplateAdded(address newAuction, uint256 templateId);\n\n    /// @notice Event emitted when auction template is removed.\n    event AuctionTemplateRemoved(address auction, uint256 templateId);\n\n    /// @notice Event emitted when auction is created using template id.\n    event MarketCreated(address indexed owner, address indexed addr, address marketTemplate);\n\n    constructor() public {\n    }\n\n    /**\n     * @notice Initializes the market with a list of auction templates.\n     * @dev Can only be initialized once.\n     * @param _accessControls Sets address to get the access controls from.\n     * @param _templates Initial array of MISOMarket templates.\n     */\n    function initMISOMarket(address _accessControls, address _bentoBox, address[] memory _templates) external {\n        require(!initialised);\n        require(_accessControls != address(0), \"initMISOMarket: accessControls cannot be set to zero\");\n        require(_bentoBox != address(0), \"initMISOMarket: bentoBox cannot be set to zero\");\n\n        accessControls = MISOAccessControls(_accessControls);\n        bentoBox = IBentoBoxFactory(_bentoBox);\n\n        for(uint i = 0; i < _templates.length; i++) {\n            _addAuctionTemplate(_templates[i]);\n        }\n        locked = true;\n        initialised = true;\n        emit MisoInitMarket(msg.sender);\n    }\n\n    /**\n     * @notice Sets the minimum fee.\n     * @param _amount Fee amount.\n     */\n    function setMinimumFee(uint256 _amount) external {\n        require(\n            accessControls.hasAdminRole(msg.sender),\n            \"MISOMarket: Sender must be operator\"\n        );\n        marketFees.minimumFee = BoringMath.to128(_amount);\n    }\n\n    /**\n     * @notice Sets the factory to be locked or unlocked.\n     * @param _locked bool.\n     */\n    function setLocked(bool _locked) external {\n        require(\n            accessControls.hasAdminRole(msg.sender),\n            \"MISOMarket: Sender must be admin\"\n        );\n        locked = _locked;\n    }\n\n\n    /**\n     * @notice Sets integrator fee percentage.\n     * @param _amount Percentage amount.\n     */\n    function setIntegratorFeePct(uint256 _amount) external {\n        require(\n            accessControls.hasAdminRole(msg.sender),\n            \"MISOMarket: Sender must be operator\"\n        );\n        /// @dev this is out of 1000, ie 25% = 250\n        require(_amount <= 1000, \"MISOMarket: Percentage is out of 1000\");\n        marketFees.integratorFeePct = BoringMath.to32(_amount);\n    }\n\n    /**\n     * @notice Sets dividend address.\n     * @param _divaddr Dividend address.\n     */\n    function setDividends(address payable _divaddr) external {\n        require(accessControls.hasAdminRole(msg.sender), \"MISOMarket.setDev: Sender must be operator\");\n        require(_divaddr != address(0));\n        misoDiv = _divaddr;\n    }\n\n    /**\n     * @notice Sets the current template ID for any type.\n     * @param _templateType Type of template.\n     * @param _templateId The ID of the current template for that type\n     */\n    function setCurrentTemplateId(uint256 _templateType, uint256 _templateId) external {\n        require(\n            accessControls.hasAdminRole(msg.sender),\n            \"MISOMarket: Sender must be admin\"\n        );\n        require(auctionTemplates[_templateId] != address(0), \"MISOMarket: incorrect _templateId\");\n        require(IMisoMarket(auctionTemplates[_templateId]).marketTemplate() == _templateType, \"MISOMarket: incorrect _templateType\");\n        currentTemplateId[_templateType] = _templateId;\n    }\n\n\n    /**\n     * @notice Used to check whether an address has the minter role\n     * @param _address EOA or contract being checked\n     * @return bool True if the account has the role or false if it does not\n     */\n    function hasMarketMinterRole(address _address) public view returns (bool) {\n        return accessControls.hasRole(MARKET_MINTER_ROLE, _address);\n    }\n\n\n    /**\n     * @notice Creates a new MISOMarket from template _templateId and transfers fees.\n     * @param _templateId Id of the crowdsale template to create.\n     * @param _integratorFeeAccount Address to pay the fee to.\n     * @return newMarket Market address.\n     */\n    function deployMarket(\n        uint256 _templateId,\n        address payable _integratorFeeAccount\n    )\n        public payable returns (address newMarket)\n    {\n        /// @dev If the contract is locked, only admin and minters can deploy. \n        if (locked) {\n            require(accessControls.hasAdminRole(msg.sender) \n                    || accessControls.hasMinterRole(msg.sender)\n                    || hasMarketMinterRole(msg.sender),\n                \"MISOMarket: Sender must be minter if locked\"\n            );\n        }\n\n        MarketFees memory _marketFees = marketFees;\n        address auctionTemplate = auctionTemplates[_templateId];\n        require(msg.value >= uint256(_marketFees.minimumFee), \"MISOMarket: Failed to transfer minimumFee\");\n        require(auctionTemplate != address(0), \"MISOMarket: Auction template doesn't exist\");\n        uint256 integratorFee = 0;\n        uint256 misoFee = msg.value;\n        if (_integratorFeeAccount != address(0) && _integratorFeeAccount != misoDiv) {\n            integratorFee = misoFee * uint256(_marketFees.integratorFeePct) / 1000;\n            misoFee = misoFee - integratorFee;\n        }\n\n        /// @dev Deploy using the BentoBox factory. \n        newMarket = bentoBox.deploy(auctionTemplate, \"\", false);\n        auctionInfo[newMarket] = Auction(true, BoringMath.to64(_templateId), BoringMath.to128(auctions.length));\n        auctions.push(newMarket);\n        auctionsLength++;\n        emit MarketCreated(msg.sender, newMarket, auctionTemplate);\n        if (misoFee > 0) {\n            misoDiv.transfer(misoFee);\n        }\n        if (integratorFee > 0) {\n            _integratorFeeAccount.transfer(integratorFee);\n        }\n    }\n\n    /**\n     * @notice Creates a new MISOMarket using _templateId.\n     * @dev Initializes auction with the parameters passed.\n     * @param _templateId Id of the auction template to create.\n     * @param _token The token address to be sold.\n     * @param _tokenSupply Amount of tokens to be sold at market.\n     * @param _integratorFeeAccount Address to send refferal bonus, if set.\n     * @param _data Data to be sent to template on Init.\n     * @return newMarket Market address.\n     */\n    function createMarket(\n        uint256 _templateId,\n        address _token,\n        uint256 _tokenSupply,\n        address payable _integratorFeeAccount,\n        bytes calldata _data\n    )\n        external payable returns (address newMarket)\n    {\n        newMarket = deployMarket(_templateId, _integratorFeeAccount);\n        if (_tokenSupply > 0) {\n            _safeTransferFrom(_token, msg.sender, _tokenSupply);\n            IERC20(_token).safeApprove(newMarket, _tokenSupply);\n        }\n        IMisoMarket(newMarket).initMarket(_data);\n\n        if (_tokenSupply > 0) {\n            uint256 remainingBalance = IERC20(_token).balanceOf(address(this));\n            if (remainingBalance > 0) {\n                _safeTransfer(_token, msg.sender, remainingBalance);\n            }\n        }\n        return newMarket;\n    }\n\n    /**\n     * @notice Function to add an auction template to create through factory.\n     * @dev Should have operator access.\n     * @param _template Auction template to create an auction.\n     */\n    function addAuctionTemplate(address _template) external {\n        require(\n            accessControls.hasAdminRole(msg.sender) ||\n            accessControls.hasOperatorRole(msg.sender),\n            \"MISOMarket: Sender must be operator\"\n        );\n        _addAuctionTemplate(_template);    \n    }\n\n    /**\n     * @dev Function to remove an auction template.\n     * @dev Should have operator access.\n     * @param _templateId Refers to template that is to be deleted.\n     */\n    function removeAuctionTemplate(uint256 _templateId) external {\n        require(\n            accessControls.hasAdminRole(msg.sender) ||\n            accessControls.hasOperatorRole(msg.sender),\n            \"MISOMarket: Sender must be operator\"\n        );\n        address template = auctionTemplates[_templateId];\n        uint256 templateType = IMisoMarket(template).marketTemplate();\n        if (currentTemplateId[templateType] == _templateId) {\n            delete currentTemplateId[templateType];\n        }   \n        auctionTemplates[_templateId] = address(0);\n        delete auctionTemplateToId[template];\n        emit AuctionTemplateRemoved(template, _templateId);\n    }\n\n    /**\n     * @notice Function to add an auction template to create through factory.\n     * @param _template Auction template address to create an auction.\n     */\n    function _addAuctionTemplate(address _template) internal {\n        require(_template != address(0), \"MISOMarket: Incorrect template\");\n        require(auctionTemplateToId[_template] == 0, \"MISOMarket: Template already added\");\n        uint256 templateType = IMisoMarket(_template).marketTemplate();\n        require(templateType > 0, \"MISOMarket: Incorrect template code \");\n        auctionTemplateId++;\n\n        auctionTemplates[auctionTemplateId] = _template;\n        auctionTemplateToId[_template] = auctionTemplateId;\n        currentTemplateId[templateType] = auctionTemplateId;\n        emit AuctionTemplateAdded(_template, auctionTemplateId);\n    }\n\n    /**\n     * @notice Get the address based on template ID.\n     * @param _templateId Auction template ID.\n     * @return Address of the required template ID.\n     */\n    function getAuctionTemplate(uint256 _templateId) external view returns (address) {\n        return auctionTemplates[_templateId];\n    }\n\n    /**\n     * @notice Get the ID based on template address.\n     * @param _auctionTemplate Auction template address.\n     * @return ID of the required template address.\n     */\n    function getTemplateId(address _auctionTemplate) external view returns (uint256) {\n        return auctionTemplateToId[_auctionTemplate];\n    }\n\n    /**\n     * @notice Get the total number of auctions in the factory.\n     * @return Auction count.\n     */\n    function numberOfAuctions() external view returns (uint) {\n        return auctions.length;\n    }\n\n    function minimumFee() external view returns(uint128) {\n        return marketFees.minimumFee;\n    }\n\n    function getMarkets() external view returns(address[] memory) {\n        return auctions;\n    }\n\n    function getMarketTemplateId(address _auction) external view returns(uint64) {\n        return auctionInfo[_auction].templateId;\n    }\n}\n"
    },
    "contracts/Utils/BoringMath.sol": {
      "content": "\npragma solidity 0.6.12;\n\n/// @notice A library for performing overflow-/underflow-safe math,\n/// updated with awesomeness from of DappHub (https://github.com/dapphub/ds-math).\nlibrary BoringMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        require(b == 0 || (c = a * b) / b == a, \"BoringMath: Mul Overflow\");\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        require(b > 0, \"BoringMath: Div zero\");\n        c = a / b;\n    }\n\n    function to128(uint256 a) internal pure returns (uint128 c) {\n        require(a <= uint128(-1), \"BoringMath: uint128 Overflow\");\n        c = uint128(a);\n    }\n\n    function to64(uint256 a) internal pure returns (uint64 c) {\n        require(a <= uint64(-1), \"BoringMath: uint64 Overflow\");\n        c = uint64(a);\n    }\n\n    function to32(uint256 a) internal pure returns (uint32 c) {\n        require(a <= uint32(-1), \"BoringMath: uint32 Overflow\");\n        c = uint32(a);\n    }\n\n    function to16(uint256 a) internal pure returns (uint16 c) {\n        require(a <= uint16(-1), \"BoringMath: uint16 Overflow\");\n        c = uint16(a);\n    }\n\n}\n\n/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint128.\nlibrary BoringMath128 {\n    function add(uint128 a, uint128 b) internal pure returns (uint128 c) {\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\n    }\n\n    function sub(uint128 a, uint128 b) internal pure returns (uint128 c) {\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\n    }\n}\n\n/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint64.\nlibrary BoringMath64 {\n    function add(uint64 a, uint64 b) internal pure returns (uint64 c) {\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\n    }\n\n    function sub(uint64 a, uint64 b) internal pure returns (uint64 c) {\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\n    }\n}\n\n/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint32.\nlibrary BoringMath32 {\n    function add(uint32 a, uint32 b) internal pure returns (uint32 c) {\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\n    }\n\n    function sub(uint32 a, uint32 b) internal pure returns (uint32 c) {\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\n    }\n}\n\n/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint32.\nlibrary BoringMath16 {\n    function add(uint16 a, uint16 b) internal pure returns (uint16 c) {\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\n    }\n\n    function sub(uint16 a, uint16 b) internal pure returns (uint16 c) {\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\n    }\n}"
    },
    "contracts/Utils/SafeTransfer.sol": {
      "content": "pragma solidity 0.6.12;\n\ncontract SafeTransfer {\n\n    address private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice Event for token withdrawals.\n    event TokensWithdrawn(address token, address to, uint256 amount);\n\n    /// @dev Helper function to handle both ETH and ERC20 payments\n    function _safeTokenPayment(\n        address _token,\n        address payable _to,\n        uint256 _amount\n    ) internal {\n        if (address(_token) == ETH_ADDRESS) {\n            _safeTransferETH(_to,_amount );\n        } else {\n            _safeTransfer(_token, _to, _amount);\n        }\n\n        emit TokensWithdrawn(_token, _to, _amount);\n    }\n\n\n    /// @dev Helper function to handle both ETH and ERC20 payments\n    function _tokenPayment(\n        address _token,\n        address payable _to,\n        uint256 _amount\n    ) internal {\n        if (address(_token) == ETH_ADDRESS) {\n            _to.transfer(_amount);\n        } else {\n            _safeTransfer(_token, _to, _amount);\n        }\n\n        emit TokensWithdrawn(_token, _to, _amount);\n    }\n\n\n    /// @dev Transfer helper from UniswapV2 Router\n    function _safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n    }\n\n\n    /**\n     * There are many non-compliant ERC20 tokens... this can handle most, adapted from UniSwap V2\n     * Im trying to make it a habit to put external calls last (reentrancy)\n     * You can put this in an internal function if you like.\n     */\n    function _safeTransfer(\n        address token,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        // solium-disable-next-line security/no-low-level-calls\n        (bool success, bytes memory data) =\n            token.call(\n                // 0xa9059cbb = bytes4(keccak256(\"transfer(address,uint256)\"))\n                abi.encodeWithSelector(0xa9059cbb, to, amount)\n            );\n        require(success && (data.length == 0 || abi.decode(data, (bool)))); // ERC20 Transfer failed\n    }\n\n    function _safeTransferFrom(\n        address token,\n        address from,\n        uint256 amount\n    ) internal virtual {\n        // solium-disable-next-line security/no-low-level-calls\n        (bool success, bytes memory data) =\n            token.call(\n                // 0x23b872dd = bytes4(keccak256(\"transferFrom(address,address,uint256)\"))\n                abi.encodeWithSelector(0x23b872dd, from, address(this), amount)\n            );\n        require(success && (data.length == 0 || abi.decode(data, (bool)))); // ERC20 TransferFrom failed\n    }\n\n    function _safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n    }\n\n    function _safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n    }\n\n\n}\n"
    },
    "contracts/interfaces/IMisoMarket.sol": {
      "content": "pragma solidity 0.6.12;\n\ninterface IMisoMarket {\n\n    function init(bytes calldata data) external payable;\n    function initMarket( bytes calldata data ) external;\n    function marketTemplate() external view returns (uint256);\n\n}\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "pragma solidity 0.6.12;\n\ninterface IERC20 {\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address account) external view returns (uint256);\n\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function decimals() external view returns (uint8);\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) external returns (bool);\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n}\n"
    },
    "contracts/interfaces/IBentoBoxFactory.sol": {
      "content": "pragma solidity 0.6.12;\n\ninterface IBentoBoxFactory {\n    function deploy(address masterContract, bytes calldata data, bool useCreate2) external payable returns (address cloneAddress) ;\n    function masterContractApproved(address, address) external view returns (bool);\n    function masterContractOf(address) external view returns (address);\n    function setMasterContractApproval(address user, address masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) external;\n}"
    },
    "contracts/OpenZeppelin/token/ERC20/SafeERC20.sol": {
      "content": "\n\npragma solidity 0.6.12;\n\nimport \"../../../interfaces/IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        // 0xa9059cbb = bytes4(keccak256(\"transfer(address,uint256)\"))\n        _callOptionalReturn(token, abi.encodeWithSelector(0xa9059cbb, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        // 0x23b872dd = bytes4(keccak256(\"transferFrom(address,address,uint256)\"))\n        _callOptionalReturn(token, abi.encodeWithSelector(0x23b872dd, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/OpenZeppelin/math/SafeMath.sol": {
      "content": "\n\npragma solidity 0.6.12;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/OpenZeppelin/utils/Address.sol": {
      "content": "\npragma solidity 0.6.12;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/OpenZeppelin/token/ERC20/TokenTimelock.sol": {
      "content": "\n\npragma solidity 0.6.12;\n\nimport \"./SafeERC20.sol\";\n\n/**\n * @dev A token holder contract that will allow a beneficiary to extract the\n * tokens after a given release time.\n *\n * Useful for simple vesting schedules like \"advisors get all of their tokens\n * after 1 year\".\n */\ncontract TokenTimelock {\n    using SafeERC20 for IERC20;\n\n    // ERC20 basic token contract being held\n    IERC20 private _token;\n\n    // beneficiary of tokens after they are released\n    address private _beneficiary;\n\n    // timestamp when token release is enabled\n    uint256 private _releaseTime;\n\n    constructor (IERC20 token_, address beneficiary_, uint256 releaseTime_) public {\n        // solhint-disable-next-line not-rely-on-time\n        require(releaseTime_ > block.timestamp, \"TokenTimelock: release time is before current time\");\n        _token = token_;\n        _beneficiary = beneficiary_;\n        _releaseTime = releaseTime_;\n    }\n\n    /**\n     * @return the token being held.\n     */\n    function token() public view virtual returns (IERC20) {\n        return _token;\n    }\n\n    /**\n     * @return the beneficiary of the tokens.\n     */\n    function beneficiary() public view virtual returns (address) {\n        return _beneficiary;\n    }\n\n    /**\n     * @return the time when the tokens are released.\n     */\n    function releaseTime() public view virtual returns (uint256) {\n        return _releaseTime;\n    }\n\n    /**\n     * @notice Transfers tokens held by timelock to beneficiary.\n     */\n    function release() public virtual {\n        // solhint-disable-next-line not-rely-on-time\n        require(block.timestamp >= releaseTime(), \"TokenTimelock: current time is before release time\");\n\n        uint256 amount = token().balanceOf(address(this));\n        require(amount > 0, \"TokenTimelock: no tokens to release\");\n\n        token().safeTransfer(beneficiary(), amount);\n    }\n}\n"
    },
    "contracts/Utils/Timelock.sol": {
      "content": "// COPIED FROM https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/GovernorAlpha.sol\n// Copyright 2020 Compound Labs, Inc.\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n// 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n\npragma solidity 0.6.12;\n\nimport \"../OpenZeppelin/math/SafeMath.sol\";\n\ncontract Timelock {\n    using SafeMath for uint;\n\n    event NewAdmin(address indexed newAdmin);\n    event NewPendingAdmin(address indexed newPendingAdmin);\n    event NewDelay(uint indexed newDelay);\n    event CancelTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature,  bytes data, uint eta);\n    event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature,  bytes data, uint eta);\n    event QueueTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint eta);\n\n    uint public constant GRACE_PERIOD = 14 days;\n    uint public constant MINIMUM_DELAY = 2 days;\n    uint public constant MAXIMUM_DELAY = 30 days;\n\n    address public admin;\n    address public pendingAdmin;\n    uint public delay;\n    bool public admin_initialized;\n\n    mapping (bytes32 => bool) public queuedTransactions;\n\n\n    constructor(address admin_, uint delay_) public {\n        require(delay_ >= MINIMUM_DELAY, \"Timelock::constructor: Delay must exceed minimum delay.\");\n        require(delay_ <= MAXIMUM_DELAY, \"Timelock::constructor: Delay must not exceed maximum delay.\");\n\n        admin = admin_;\n        delay = delay_;\n        admin_initialized = false;\n    }\n\n    receive() external payable { }\n\n    function setDelay(uint delay_) public {\n        require(msg.sender == address(this), \"Timelock::setDelay: Call must come from Timelock.\");\n        require(delay_ >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\");\n        require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n        delay = delay_;\n\n        emit NewDelay(delay);\n    }\n\n    function acceptAdmin() public {\n        require(msg.sender == pendingAdmin, \"Timelock::acceptAdmin: Call must come from pendingAdmin.\");\n        admin = msg.sender;\n        pendingAdmin = address(0);\n\n        emit NewAdmin(admin);\n    }\n\n    function setPendingAdmin(address pendingAdmin_) public {\n        // allows one time setting of admin for deployment purposes\n        if (admin_initialized) {\n            require(msg.sender == address(this), \"Timelock::setPendingAdmin: Call must come from Timelock.\");\n        } else {\n            require(msg.sender == admin, \"Timelock::setPendingAdmin: First call must come from admin.\");\n            admin_initialized = true;\n        }\n        pendingAdmin = pendingAdmin_;\n\n        emit NewPendingAdmin(pendingAdmin);\n    }\n\n    function queueTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public returns (bytes32) {\n        require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\n        require(eta >= getBlockTimestamp().add(delay), \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = true;\n\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\n        return txHash;\n    }\n\n    function cancelTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public {\n        require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = false;\n\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\n    }\n\n    function executeTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public payable returns (bytes memory) {\n        require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\n        require(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\n        require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), \"Timelock::executeTransaction: Transaction is stale.\");\n\n        queuedTransactions[txHash] = false;\n\n        bytes memory callData;\n\n        if (bytes(signature).length == 0) {\n            callData = data;\n        } else {\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n        }\n\n        // solium-disable-next-line security/no-call-value\n        (bool success, bytes memory returnData) = target.call.value(value)(callData);\n    \n        require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\n\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n        return returnData;\n    }\n\n    function getBlockTimestamp() internal view returns (uint) {\n        // solium-disable-next-line security/no-block-members\n        return block.timestamp;\n    }\n}"
    },
    "contracts/OpenZeppelin/utils/Counters.sol": {
      "content": "\n\npragma solidity 0.6.12;\n\nimport \"../math/SafeMath.sol\";\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the {SafeMath}\n * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\n * directly accessed.\n */\nlibrary Counters {\n    using SafeMath for uint256;\n\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        // The {SafeMath} overflow check can be skipped here, see the comment at the top\n        counter._value += 1;\n    }\n\n    function decrement(Counter storage counter) internal {\n        counter._value = counter._value.sub(1);\n    }\n}\n"
    },
    "contracts/interfaces/IWETH9.sol": {
      "content": "pragma solidity 0.6.12;\n\nimport \"./IERC20.sol\";\n\ninterface IWETH is IERC20 {\n    function deposit() external payable;\n    function withdraw(uint) external;\n    function transfer(address, uint) external returns (bool);\n\n}"
    },
    "contracts/Gatekeeper.sol": {
      "content": "pragma solidity 0.6.12;\n\nimport \"./interfaces/IERC20.sol\";\nimport \"./Access/MISOAccessControls.sol\";\nimport \"./interfaces/IGatekeeper.sol\";\n\ncontract Gatekeeper is IGatekeeper, MISOAccessControls {\n    IERC20 public creamy;\n\n    mapping(address => uint256) public policies;\n    \n    constructor (address _creamy) public {\n        creamy = IERC20(_creamy);\n    }\n\n    function setPolicy(address _auction, uint256 _minimum) external {\n        require(hasAdminRole(msg.sender), \"Unauthorized\");\n        policies[_auction] = _minimum;\n    }\n\n    function checkPolicy(address _user, uint256 _amount) external override returns (bool _accepted) {\n        _accepted = creamy.balanceOf(_user) >= policies[msg.sender];\n    }\n}"
    },
    "contracts/interfaces/IGatekeeper.sol": {
      "content": "pragma solidity 0.6.12;\n\ninterface IGatekeeper {\n    function checkPolicy(address _user, uint256 _amount) external returns (bool);\n}"
    },
    "contracts/Auctions/DutchAuction.sol": {
      "content": "pragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\n\n//----------------------------------------------------------------------------------\n//    I n s t a n t\n//\n//        .:mmm.         .:mmm:.       .ii.  .:SSSSSSSSSSSSS.     .oOOOOOOOOOOOo.  \n//      .mMM'':Mm.     .:MM'':Mm:.     .II:  :SSs..........     .oOO'''''''''''OOo.\n//    .:Mm'   ':Mm.   .:Mm'   'MM:.    .II:  'sSSSSSSSSSSSSS:.  :OO.           .OO:\n//  .'mMm'     ':MM:.:MMm'     ':MM:.  .II:  .:...........:SS.  'OOo:.........:oOO'\n//  'mMm'        ':MMmm'         'mMm:  II:  'sSSSSSSSSSSSSS'     'oOOOOOOOOOOOO'  \n//\n//----------------------------------------------------------------------------------\n//\n// Chef Gonpachi's Dutch Auction\n//\n// A declining price auction with fair price discovery. \n//\n// Inspired by DutchSwap's Dutch Auctions\n// https://github.com/deepyr/DutchSwap\n// \n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// The above copyright notice and this permission notice shall be included \n// in all copies or substantial portions of the Software.\n//\n// Made for Sushi.com \n// \n// Enjoy. (c) Chef Gonpachi, Kusatoshi, SSMikazu 2021 \n// <https://github.com/chefgonpachi/MISO/>\n//\n// ---------------------------------------------------------------------\n// SPDX-License-Identifier: GPL-3.0                        \n// ---------------------------------------------------------------------\n\nimport \"../OpenZeppelin/utils/ReentrancyGuard.sol\";\nimport \"../Access/MISOAccessControls.sol\";\nimport \"../Utils/SafeTransfer.sol\";\nimport \"../Utils/BoringBatchable.sol\";\nimport \"../Utils/BoringMath.sol\";\nimport \"../Utils/BoringERC20.sol\";\nimport \"../Utils/Documents.sol\";\nimport \"../interfaces/IPointList.sol\";\nimport \"../interfaces/IMisoMarket.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IGatekeeper.sol\";\n\n/// @notice Attribution to delta.financial\n/// @notice Attribution to dutchswap.com\n\ncontract DutchAuction is IMisoMarket, MISOAccessControls, BoringBatchable, SafeTransfer, Documents , ReentrancyGuard  {\n    using BoringMath for uint256;\n    using BoringMath128 for uint128;\n    using BoringMath64 for uint64;\n    using BoringERC20 for IERC20;\n\n    /// @notice MISOMarket template id for the factory contract.\n    /// @dev For different marketplace types, this must be incremented.\n    uint256 public constant override marketTemplate = 1;\n    /// @dev The placeholder ETH address.\n    address private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    uint256 public fee = 0;\n    uint256 public constant feeDenominator = 10000;\n    address payable public feeWallet;\n\n    IGatekeeper public gatekeeper;\n\n    /// @notice Main market variables.\n    struct MarketInfo {\n        uint64 startTime;\n        uint64 endTime;\n        uint128 totalTokens;\n    }\n    MarketInfo public marketInfo;\n\n    /// @notice Market price variables.\n    struct MarketPrice {\n        uint128 startPrice;\n        uint128 minimumPrice;\n    }\n    MarketPrice public marketPrice;\n\n    /// @notice Market dynamic variables.\n    struct MarketStatus {\n        uint128 commitmentsTotal;\n        bool finalized;\n        bool usePointList;\n    }\n\n    MarketStatus public marketStatus;\n\n    /// @notice The token being sold.\n    address public auctionToken; \n    /// @notice The currency the auction accepts for payment. Can be ETH or token address.\n    address public paymentCurrency;  \n    /// @notice Where the auction funds will get paid.\n    address payable public wallet;  \n    /// @notice Address that manages auction approvals.\n    address public pointList;\n\n    /// @notice The committed amount of accounts.\n    mapping(address => uint256) public commitments; \n    /// @notice Amount of tokens to claim per address.\n    mapping(address => uint256) public claimed;\n\n    /// @notice Event for all auction data. Emmited on deployment.\n    event AuctionDeployed(address funder, address token, uint256 totalTokens, address paymentCurrency, address admin, address wallet);\n    \n    /// @notice Event for updating auction times.  Needs to be before auction starts.\n    event AuctionTimeUpdated(uint256 startTime, uint256 endTime); \n    /// @notice Event for updating auction prices. Needs to be before auction starts.\n    event AuctionPriceUpdated(uint256 startPrice, uint256 minimumPrice); \n    /// @notice Event for updating auction wallet. Needs to be before auction starts.\n    event AuctionWalletUpdated(address wallet); \n    /// @notice Event for updating the point list.\n    event AuctionPointListUpdated(address pointList, bool enabled);\n\n    /// @notice Event for adding a commitment.\n    event AddedCommitment(address addr, uint256 commitment);   \n    /// @notice Event for token withdrawals.\n    event TokensWithdrawn(address token, address to, uint256 amount);\n    \n    /// @notice Event for finalization of the auction.\n    event AuctionFinalized();\n    /// @notice Event for cancellation of the auction.\n    event AuctionCancelled();\n\n    /**\n     * @notice Initializes main contract variables and transfers funds for the auction.\n     * @dev Init function.\n     * @param _funder The address that funds the token for DutchAuction.\n     * @param _token Address of the token being sold.\n     * @param _totalTokens The total number of tokens to sell in auction.\n     * @param _startTime Auction start time.\n     * @param _endTime Auction end time.\n     * @param _paymentCurrency The currency the DutchAuction accepts for payment. Can be ETH or token address.\n     * @param _startPrice Starting price of the auction.\n     * @param _minimumPrice The minimum auction price.\n     * @param _admin Address that can finalize auction.\n     * @param _pointList Address that will manage auction approvals.\n     * @param _wallet Address where collected funds will be forwarded to.\n     */\n    function initAuction(\n        address _funder,\n        address _token,\n        uint256 _totalTokens,\n        uint256 _startTime,\n        uint256 _endTime,\n        address _paymentCurrency,\n        uint256 _startPrice,\n        uint256 _minimumPrice,\n        address _admin,\n        address _pointList,\n        address payable _wallet,\n        address _gatekeeper\n    ) public {\n        require(_endTime < 10000000000, \"DutchAuction: enter an unix timestamp in seconds, not miliseconds\");\n        require(_startTime >= block.timestamp, \"DutchAuction: start time is before current time\");\n        require(_endTime > _startTime, \"DutchAuction: end time must be older than start price\");\n        require(_totalTokens > 0,\"DutchAuction: total tokens must be greater than zero\");\n        require(_startPrice > _minimumPrice, \"DutchAuction: start price must be higher than minimum price\");\n        require(_minimumPrice > 0, \"DutchAuction: minimum price must be greater than 0\"); \n        require(_admin != address(0), \"DutchAuction: admin is the zero address\");\n        require(_wallet != address(0), \"DutchAuction: wallet is the zero address\");\n        require(IERC20(_token).decimals() == 18, \"DutchAuction: Token does not have 18 decimals\");\n        if (_paymentCurrency != ETH_ADDRESS) {\n            require(IERC20(_paymentCurrency).decimals() > 0, \"DutchAuction: Payment currency is not ERC20\");\n        }\n\n        marketInfo.startTime = BoringMath.to64(_startTime);\n        marketInfo.endTime = BoringMath.to64(_endTime);\n        marketInfo.totalTokens = BoringMath.to128(_totalTokens);\n\n        marketPrice.startPrice = BoringMath.to128(_startPrice);\n        marketPrice.minimumPrice = BoringMath.to128(_minimumPrice);\n\n        auctionToken = _token;\n        paymentCurrency = _paymentCurrency;\n        wallet = _wallet;\n        gatekeeper = IGatekeeper(_gatekeeper);\n\n        initAccessControls(_admin);\n\n        _setList(_pointList);\n        _safeTransferFrom(_token, _funder, _totalTokens);\n\n        emit AuctionDeployed(_funder, _token, _totalTokens, _paymentCurrency, _admin, _wallet);\n        emit AuctionTimeUpdated(_startTime, _endTime);\n        emit AuctionPriceUpdated(_startPrice, _minimumPrice);\n    }\n\n\n\n    /**\n     Dutch Auction Price Function\n     ============================\n     \n     Start Price -----\n                      \\\n                       \\\n                        \\\n                         \\ ------------ Clearing Price\n                        / \\            = AmountRaised/TokenSupply\n         Token Price  --   \\\n                     /      \\\n                   --        ----------- Minimum Price\n     Amount raised /          End Time\n    */\n\n    /**\n     * @notice Calculates the average price of each token from all commitments.\n     * @return Average token price.\n     */\n    function tokenPrice() public view returns (uint256) {\n        return uint256(marketStatus.commitmentsTotal)\n            .mul(1e18).div(uint256(marketInfo.totalTokens));\n    }\n\n    /**\n     * @notice Returns auction price in any time.\n     * @return Fixed start price or minimum price if outside of auction time, otherwise calculated current price.\n     */\n    function priceFunction() public view returns (uint256) {\n        /// @dev Return Auction Price\n        if (block.timestamp <= uint256(marketInfo.startTime)) {\n            return uint256(marketPrice.startPrice);\n        }\n        if (block.timestamp >= uint256(marketInfo.endTime)) {\n            return uint256(marketPrice.minimumPrice);\n        }\n\n        return _currentPrice();\n    }\n\n    /**\n     * @notice The current clearing price of the Dutch auction.\n     * @return The bigger from tokenPrice and priceFunction.\n     */\n    function clearingPrice() public view returns (uint256) {\n\n        /// @dev If auction successful, return tokenPrice\n        uint256 _tokenPrice = tokenPrice();\n        uint256 _currentPrice = priceFunction();\n        return _tokenPrice > _currentPrice ? _tokenPrice : _currentPrice;\n\n    }\n\n\n    ///--------------------------------------------------------\n    /// Commit to buying tokens!\n    ///--------------------------------------------------------\n\n    receive() external payable {\n        revertBecauseUserDidNotProvideAgreement();\n    }\n\n    /** \n     * @dev Attribution to the awesome delta.financial contracts\n    */  \n    function marketParticipationAgreement() public pure returns (string memory) {\n        return \"I understand that I'm interacting with a smart contract. I understand that tokens committed are subject to the token issuer and local laws where applicable. I reviewed code of the smart contract and understand it fully. I agree to not hold developers or other people associated with the project liable for any losses or misunderstandings\";\n    }\n    /** \n     * @dev Not using modifiers is a purposeful choice for code readability.\n    */ \n    function revertBecauseUserDidNotProvideAgreement() internal pure {\n        revert(\"No agreement provided, please review the smart contract before interacting with it\");\n    }\n\n    /**\n     * @notice Checks the amount of ETH to commit and adds the commitment. Refunds the buyer if commit is too high.\n     * @param _beneficiary Auction participant ETH address.\n     */\n    function commitEth(\n        address payable _beneficiary,\n        bool readAndAgreedToMarketParticipationAgreement\n    )\n        public payable\n    {\n        require(paymentCurrency == ETH_ADDRESS, \"DutchAuction: payment currency is not ETH address\"); \n        if(readAndAgreedToMarketParticipationAgreement == false) {\n            revertBecauseUserDidNotProvideAgreement();\n        }\n        // Get ETH able to be committed\n        uint256 ethToTransfer = calculateCommitment(msg.value);\n\n        /// @notice Accept ETH Payments.\n        uint256 ethToRefund = msg.value.sub(ethToTransfer);\n        if (ethToTransfer > 0) {\n            _addCommitment(_beneficiary, ethToTransfer);\n        }\n        /// @notice Return any ETH to be refunded.\n        if (ethToRefund > 0) {\n            _beneficiary.transfer(ethToRefund);\n        }\n\n        /// @notice Revert if commitmentsTotal exceeds the balance\n        require(marketStatus.commitmentsTotal <= address(this).balance, \"DutchAuction: The committed ETH exceeds the balance\");\n    }\n\n    /**\n     * @notice Buy Tokens by commiting approved ERC20 tokens to this contract address.\n     * @param _amount Amount of tokens to commit.\n     */\n    function commitTokens(uint256 _amount, bool readAndAgreedToMarketParticipationAgreement) public {\n        commitTokensFrom(msg.sender, _amount, readAndAgreedToMarketParticipationAgreement);\n    }\n\n\n    /**\n     * @notice Checks how much is user able to commit and processes that commitment.\n     * @dev Users must approve contract prior to committing tokens to auction.\n     * @param _from User ERC20 address.\n     * @param _amount Amount of approved ERC20 tokens.\n     */\n    function commitTokensFrom(\n        address _from,\n        uint256 _amount,\n        bool readAndAgreedToMarketParticipationAgreement\n    )\n        public   nonReentrant  \n    {\n        require(address(paymentCurrency) != ETH_ADDRESS, \"DutchAuction: Payment currency is not a token\");\n        require(gatekeeper.checkPolicy(_from, _amount), \"GET CREAMIER\");\n        if(readAndAgreedToMarketParticipationAgreement == false) {\n            revertBecauseUserDidNotProvideAgreement();\n        }\n        uint256 tokensToTransfer = calculateCommitment(_amount);\n        if (tokensToTransfer > 0) {\n            _safeTransferFrom(paymentCurrency, msg.sender, tokensToTransfer);\n            _addCommitment(_from, tokensToTransfer);\n        }\n    }\n\n    /**\n     * @notice Calculates the pricedrop factor.\n     * @return Value calculated from auction start and end price difference divided the auction duration.\n     */\n    function priceDrop() public view returns (uint256) {\n        MarketInfo memory _marketInfo = marketInfo;\n        MarketPrice memory _marketPrice = marketPrice;\n\n        uint256 numerator = uint256(_marketPrice.startPrice.sub(_marketPrice.minimumPrice));\n        uint256 denominator = uint256(_marketInfo.endTime.sub(_marketInfo.startTime));\n        return numerator / denominator;\n    }\n\n\n   /**\n     * @notice How many tokens the user is able to claim.\n     * @param _user Auction participant address.\n     * @return claimerCommitment User commitments reduced by already claimed tokens.\n     */\n    function tokensClaimable(address _user) public view returns (uint256 claimerCommitment) {\n        if (commitments[_user] == 0) return 0;\n        uint256 unclaimedTokens = IERC20(auctionToken).balanceOf(address(this));\n\n        claimerCommitment = commitments[_user].mul(uint256(marketInfo.totalTokens)).div(uint256(marketStatus.commitmentsTotal));\n        uint256 auctionFee = claimerCommitment.mul(fee).div(feeDenominator);\n        claimerCommitment = claimerCommitment.sub(auctionFee).sub(claimed[_user]);\n\n        if(claimerCommitment > unclaimedTokens){\n            claimerCommitment = unclaimedTokens;\n        }\n    }\n\n    /**\n     * @notice Calculates total amount of tokens committed at current auction price.\n     * @return Number of tokens committed.\n     */\n    function totalTokensCommitted() public view returns (uint256) {\n        return uint256(marketStatus.commitmentsTotal).mul(1e18).div(clearingPrice());\n    }\n\n    /**\n     * @notice Calculates the amount able to be committed during an auction.\n     * @param _commitment Commitment user would like to make.\n     * @return committed Amount allowed to commit.\n     */\n    function calculateCommitment(uint256 _commitment) public view returns (uint256 committed) {\n        uint256 maxCommitment = uint256(marketInfo.totalTokens).mul(clearingPrice()).div(1e18);\n        if (uint256(marketStatus.commitmentsTotal).add(_commitment) > maxCommitment) {\n            return maxCommitment.sub(uint256(marketStatus.commitmentsTotal));\n        }\n        return _commitment;\n    }\n\n    /**\n     * @notice Checks if the auction is open.\n     * @return True if current time is greater than startTime and less than endTime.\n     */\n    function isOpen() public view returns (bool) {\n        return block.timestamp >= uint256(marketInfo.startTime) && block.timestamp <= uint256(marketInfo.endTime);\n    }\n\n    /**\n     * @notice Successful if tokens sold equals totalTokens.\n     * @return True if tokenPrice is bigger or equal clearingPrice.\n     */\n    function auctionSuccessful() public view returns (bool) {\n        return tokenPrice() >= clearingPrice();\n    }\n\n    /**\n     * @notice Checks if the auction has ended.\n     * @return True if auction is successful or time has ended.\n     */\n    function auctionEnded() public view returns (bool) {\n        return auctionSuccessful() || block.timestamp > uint256(marketInfo.endTime);\n    }\n\n    /**\n     * @return Returns true if market has been finalized\n     */\n    function finalized() public view returns (bool) {\n        return marketStatus.finalized;\n    }\n\n    /**\n     * @return Returns true if 7 days have passed since the end of the auction\n     */\n    function finalizeTimeExpired() public view returns (bool) {\n        return uint256(marketInfo.endTime) + 7 days < block.timestamp;\n    }\n\n    /**\n     * @notice Calculates price during the auction.\n     * @return Current auction price.\n     */\n    function _currentPrice() private view returns (uint256) {\n        MarketInfo memory _marketInfo = marketInfo;\n        MarketPrice memory _marketPrice = marketPrice;\n        uint256 priceDiff = block.timestamp.sub(uint256(_marketInfo.startTime)).mul(\n            uint256(_marketPrice.startPrice.sub(_marketPrice.minimumPrice))\n        ) / uint256(_marketInfo.endTime.sub(_marketInfo.startTime));        \n        return uint256(_marketPrice.startPrice).sub(priceDiff);\n    }\n\n    /**\n     * @notice Updates commitment for this address and total commitment of the auction.\n     * @param _addr Bidders address.\n     * @param _commitment The amount to commit.\n     */\n    function _addCommitment(address _addr, uint256 _commitment) internal {\n        require(block.timestamp >= uint256(marketInfo.startTime) && block.timestamp <= uint256(marketInfo.endTime), \"DutchAuction: outside auction hours\");\n        MarketStatus storage status = marketStatus;\n        \n        uint256 newCommitment = commitments[_addr].add(_commitment);\n        if (status.usePointList) {\n            require(IPointList(pointList).hasPoints(_addr, newCommitment));\n        }\n        \n        commitments[_addr] = newCommitment;\n        status.commitmentsTotal = BoringMath.to128(uint256(status.commitmentsTotal).add(_commitment));\n        emit AddedCommitment(_addr, _commitment);\n    }\n\n\n    //--------------------------------------------------------\n    // Finalize Auction\n    //--------------------------------------------------------\n\n\n    /**\n     * @notice Cancel Auction\n     * @dev Admin can cancel the auction before it starts\n     */\n    function cancelAuction() public   nonReentrant  \n    {\n        require(hasAdminRole(msg.sender));\n        MarketStatus storage status = marketStatus;\n        require(!status.finalized, \"DutchAuction: auction already finalized\");\n        require( uint256(status.commitmentsTotal) == 0, \"DutchAuction: auction already committed\" );\n        _safeTokenPayment(auctionToken, wallet, uint256(marketInfo.totalTokens));\n        status.finalized = true;\n        \n        emit AuctionCancelled();\n    }\n\n    /**\n     * @notice Auction finishes successfully above the reserve.\n     * @dev Transfer contract funds to initialized wallet.\n     */\n    function finalize() public   nonReentrant  \n    {\n\n        require(hasAdminRole(msg.sender) \n                || hasSmartContractRole(msg.sender) \n                || wallet == msg.sender\n                || finalizeTimeExpired(), \"DutchAuction: sender must be an admin\");\n        \n        require(marketInfo.totalTokens > 0, \"Not initialized\");\n\n        MarketStatus storage status = marketStatus;\n\n        require(!status.finalized, \"DutchAuction: auction already finalized\");\n        if (auctionSuccessful()) {\n            /// @dev Successful auction\n            /// @dev Transfer contributed tokens to wallet.\n            _safeTokenPayment(paymentCurrency, wallet, uint256(status.commitmentsTotal));\n            if (fee > 0) {\n                uint256 feeTokens = fee.mul(marketInfo.totalTokens).div(feeDenominator);\n                _safeTokenPayment(auctionToken, feeWallet, feeTokens);\n            }\n        } else {\n            /// @dev Failed auction\n            /// @dev Return auction tokens back to wallet.\n            require(block.timestamp > uint256(marketInfo.endTime), \"DutchAuction: auction has not finished yet\"); \n            _safeTokenPayment(auctionToken, wallet, uint256(marketInfo.totalTokens));\n        }\n        status.finalized = true;\n        emit AuctionFinalized();\n    }\n\n\n    /// @notice Withdraws bought tokens, or returns commitment if the sale is unsuccessful.\n    function withdrawTokens() public  {\n        withdrawTokens(msg.sender);\n    }\n\n   /**\n     * @notice Withdraws bought tokens, or returns commitment if the sale is unsuccessful.\n     * @dev Withdraw tokens only after auction ends.\n     * @param beneficiary Whose tokens will be withdrawn.\n     */\n    function withdrawTokens(address payable beneficiary) public   nonReentrant  {\n        if (auctionSuccessful()) {\n            require(marketStatus.finalized, \"DutchAuction: not finalized\");\n            /// @dev Successful auction! Transfer claimed tokens.\n            uint256 tokensToClaim = tokensClaimable(beneficiary);\n            require(tokensToClaim > 0, \"DutchAuction: No tokens to claim\"); \n            claimed[beneficiary] = claimed[beneficiary].add(tokensToClaim);\n            _safeTokenPayment(auctionToken, beneficiary, tokensToClaim);\n        } else {\n            /// @dev Auction did not meet reserve price.\n            /// @dev Return committed funds back to user.\n            require(block.timestamp > uint256(marketInfo.endTime), \"DutchAuction: auction has not finished yet\");\n            uint256 fundsCommitted = commitments[beneficiary];\n            commitments[beneficiary] = 0; // Stop multiple withdrawals and free some gas\n            _safeTokenPayment(paymentCurrency, beneficiary, fundsCommitted);\n        }\n    }\n\n\n    //--------------------------------------------------------\n    // Documents\n    //--------------------------------------------------------\n\n    function setDocument(string calldata _name, string calldata _data) external {\n        require(hasAdminRole(msg.sender) );\n        _setDocument( _name, _data);\n    }\n\n    function setDocuments(string[] calldata _name, string[] calldata _data) external {\n        require(hasAdminRole(msg.sender) );\n        uint256 numDocs = _name.length;\n        for (uint256 i = 0; i < numDocs; i++) {\n            _setDocument( _name[i], _data[i]);\n        }\n    }\n\n    function removeDocument(string calldata _name) external {\n        require(hasAdminRole(msg.sender));\n        _removeDocument(_name);\n    }\n\n\n    //--------------------------------------------------------\n    // Point Lists\n    //--------------------------------------------------------\n\n\n    function setList(address _list) external {\n        require(hasAdminRole(msg.sender));\n        _setList(_list);\n    }\n\n    function enableList(bool _status) external {\n        require(hasAdminRole(msg.sender));\n        marketStatus.usePointList = _status;\n\n        emit AuctionPointListUpdated(pointList, marketStatus.usePointList);\n    }\n\n    function _setList(address _pointList) private {\n        if (_pointList != address(0)) {\n            pointList = _pointList;\n            marketStatus.usePointList = true;\n        }\n\n        emit AuctionPointListUpdated(pointList, marketStatus.usePointList);\n    }\n\n    //--------------------------------------------------------\n    // Setter Functions\n    //--------------------------------------------------------\n\n    /**\n     * @notice Admin can set start and end time through this function.\n     * @param _startTime Auction start time.\n     * @param _endTime Auction end time.\n     */\n    function setAuctionTime(uint256 _startTime, uint256 _endTime) external {\n        require(hasAdminRole(msg.sender));\n        require(_startTime < 10000000000, \"DutchAuction: enter an unix timestamp in seconds, not miliseconds\");\n        require(_endTime < 10000000000, \"DutchAuction: enter an unix timestamp in seconds, not miliseconds\");\n        require(_startTime >= block.timestamp, \"DutchAuction: start time is before current time\");\n        require(_endTime > _startTime, \"DutchAuction: end time must be older than start time\");\n        require(marketStatus.commitmentsTotal == 0, \"DutchAuction: auction cannot have already started\");\n\n        marketInfo.startTime = BoringMath.to64(_startTime);\n        marketInfo.endTime = BoringMath.to64(_endTime);\n        \n        emit AuctionTimeUpdated(_startTime,_endTime);\n    }\n\n    /**\n     * @notice Admin can set start and min price through this function.\n     * @param _startPrice Auction start price.\n     * @param _minimumPrice Auction minimum price.\n     */\n    function setAuctionPrice(uint256 _startPrice, uint256 _minimumPrice) external {\n        require(hasAdminRole(msg.sender));\n        require(_startPrice > _minimumPrice, \"DutchAuction: start price must be higher than minimum price\");\n        require(_minimumPrice > 0, \"DutchAuction: minimum price must be greater than 0\"); \n        require(marketStatus.commitmentsTotal == 0, \"DutchAuction: auction cannot have already started\");\n\n        marketPrice.startPrice = BoringMath.to128(_startPrice);\n        marketPrice.minimumPrice = BoringMath.to128(_minimumPrice);\n\n        emit AuctionPriceUpdated(_startPrice,_minimumPrice);\n    }\n\n    /**\n     * @notice Admin can set the auction wallet through this function.\n     * @param _wallet Auction wallet is where funds will be sent.\n     */\n    function setAuctionWallet(address payable _wallet) external {\n        require(hasAdminRole(msg.sender));\n        require(_wallet != address(0), \"DutchAuction: wallet is the zero address\");\n\n        wallet = _wallet;\n\n        emit AuctionWalletUpdated(_wallet);\n    }\n\n    function setFeeInfo(uint256 _fee, address payable _feeWallet) external {\n        require(hasAdminRole(msg.sender), \"Unauthorized\");\n        require(!marketStatus.finalized, \"Auction finalized\");\n        fee = _fee;\n        feeWallet = _feeWallet;\n    }\n\n    function setGatekeeper(address _gatekeeper) external {\n        require(hasAdminRole(msg.sender), \"Unauthorized\");\n        gatekeeper = IGatekeeper(_gatekeeper);\n    }\n\n\n   //--------------------------------------------------------\n    // Market Launchers\n    //--------------------------------------------------------\n\n    /**\n     * @notice Decodes and hands auction data to the initAuction function.\n     * @param _data Encoded data for initialization.\n     */\n\n    function init(bytes calldata _data) external override payable {\n\n    }\n\n    function initMarket(\n        bytes calldata _data\n    ) public override {\n        (\n        address _funder,\n        address _token,\n        uint256 _totalTokens,\n        uint256 _startTime,\n        uint256 _endTime,\n        address _paymentCurrency,\n        uint256 _startPrice,\n        uint256 _minimumPrice,\n        address _admin,\n        address _pointList,\n        address payable _wallet,\n        address gatekeeper\n        ) = abi.decode(_data, (\n            address,\n            address,\n            uint256,\n            uint256,\n            uint256,\n            address,\n            uint256,\n            uint256,\n            address,\n            address,\n            address,\n            address\n        ));\n        initAuction(_funder, _token, _totalTokens, _startTime, _endTime, _paymentCurrency, _startPrice, _minimumPrice, _admin, _pointList, _wallet, gatekeeper);\n    }\n\n    /**\n     * @notice Collects data to initialize the auction and encodes them.\n     * @param _funder The address that funds the token for DutchAuction.\n     * @param _token Address of the token being sold.\n     * @param _totalTokens The total number of tokens to sell in auction.\n     * @param _startTime Auction start time.\n     * @param _endTime Auction end time.\n     * @param _paymentCurrency The currency the DutchAuction accepts for payment. Can be ETH or token address.\n     * @param _startPrice Starting price of the auction.\n     * @param _minimumPrice The minimum auction price.\n     * @param _admin Address that can finalize auction.\n     * @param _pointList Address that will manage auction approvals.\n     * @param _wallet Address where collected funds will be forwarded to.\n     * @return _data All the data in bytes format.\n     */\n    function getAuctionInitData(\n        address _funder,\n        address _token,\n        uint256 _totalTokens,\n        uint256 _startTime,\n        uint256 _endTime,\n        address _paymentCurrency,\n        uint256 _startPrice,\n        uint256 _minimumPrice,\n        address _admin,\n        address _pointList,\n        address payable _wallet\n    )\n        external \n        pure\n        returns (bytes memory _data)\n    {\n            return abi.encode(\n                _funder,\n                _token,\n                _totalTokens,\n                _startTime,\n                _endTime,\n                _paymentCurrency,\n                _startPrice,\n                _minimumPrice,\n                _admin,\n                _pointList,\n                _wallet\n            );\n    }\n        \n    function getBaseInformation() external view returns(\n        address, \n        uint64,\n        uint64,\n        bool \n    ) {\n        return (auctionToken, marketInfo.startTime, marketInfo.endTime, marketStatus.finalized);\n    }\n\n    function getTotalTokens() external view returns(uint256) {\n        return uint256(marketInfo.totalTokens);\n    }\n\n}\n"
    },
    "contracts/OpenZeppelin/utils/ReentrancyGuard.sol": {
      "content": "\n\npragma solidity 0.6.12;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/Utils/BoringBatchable.sol": {
      "content": "\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\n// solhint-disable avoid-low-level-calls\n// solhint-disable no-inline-assembly\n\n// Audit on 5-Jan-2021 by Keno and BoringCrypto\n\nimport \"./BoringERC20.sol\";\n\ncontract BaseBoringBatchable {\n    /// @dev Helper function to extract a useful revert message from a failed call.\n    /// If the returned data is malformed or not correctly abi encoded then this call can fail itself.\n    function _getRevertMsg(bytes memory _returnData) internal pure returns (string memory) {\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n        if (_returnData.length < 68) return \"Transaction reverted silently\";\n\n        assembly {\n            // Slice the sighash.\n            _returnData := add(_returnData, 0x04)\n        }\n        return abi.decode(_returnData, (string)); // All that remains is the revert string\n    }\n\n    /// @notice Allows batched call to self (this contract).\n    /// @param calls An array of inputs for each call.\n    /// @param revertOnFail If True then reverts after a failed call and stops doing further calls.\n    /// @return successes An array indicating the success of a call, mapped one-to-one to `calls`.\n    /// @return results An array with the returned data of each function call, mapped one-to-one to `calls`.\n    // F1: External is ok here because this is the batch function, adding it to a batch makes no sense\n    // F2: Calls in the batch may be payable, delegatecall operates in the same context, so each call in the batch has access to msg.value\n    // C3: The length of the loop is fully under user control, so can't be exploited\n    // C7: Delegatecall is only used on the same contract, so it's safe\n    function batch(bytes[] calldata calls, bool revertOnFail) external payable returns (bool[] memory successes, bytes[] memory results) {\n        successes = new bool[](calls.length);\n        results = new bytes[](calls.length);\n        for (uint256 i = 0; i < calls.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(calls[i]);\n            require(success || !revertOnFail, _getRevertMsg(result));\n            successes[i] = success;\n            results[i] = result;\n        }\n    }\n}\n\ncontract BoringBatchable is BaseBoringBatchable {\n    /// @notice Call wrapper that performs `ERC20.permit` on `token`.\n    /// Lookup `IERC20.permit`.\n    // F6: Parameters can be used front-run the permit and the user's permit will fail (due to nonce or other revert)\n    //     if part of a batch this could be used to grief once as the second call would not need the permit\n    function permitToken(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        token.permit(from, to, amount, deadline, v, r, s);\n    }\n}"
    },
    "contracts/Utils/BoringERC20.sol": {
      "content": "pragma solidity 0.6.12;\nimport \"../interfaces/IERC20.sol\";\n\n// solhint-disable avoid-low-level-calls\n\nlibrary BoringERC20 {\n    bytes4 private constant SIG_SYMBOL = 0x95d89b41; // symbol()\n    bytes4 private constant SIG_NAME = 0x06fdde03; // name()\n    bytes4 private constant SIG_DECIMALS = 0x313ce567; // decimals()\n    bytes4 private constant SIG_TRANSFER = 0xa9059cbb; // transfer(address,uint256)\n    bytes4 private constant SIG_TRANSFER_FROM = 0x23b872dd; // transferFrom(address,address,uint256)\n\n    /// @notice Provides a safe ERC20.symbol version which returns '???' as fallback string.\n    /// @param token The address of the ERC-20 token contract.\n    /// @return (string) Token symbol.\n    function safeSymbol(IERC20 token) internal view returns (string memory) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_SYMBOL));\n        return success && data.length > 0 ? abi.decode(data, (string)) : \"???\";\n    }\n\n    /// @notice Provides a safe ERC20.name version which returns '???' as fallback string.\n    /// @param token The address of the ERC-20 token contract.\n    /// @return (string) Token name.\n    function safeName(IERC20 token) internal view returns (string memory) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_NAME));\n        return success && data.length > 0 ? abi.decode(data, (string)) : \"???\";\n    }\n\n    /// @notice Provides a safe ERC20.decimals version which returns '18' as fallback value.\n    /// @param token The address of the ERC-20 token contract.\n    /// @return (uint8) Token decimals.\n    function safeDecimals(IERC20 token) internal view returns (uint8) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_DECIMALS));\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\n    }\n\n    /// @notice Provides a safe ERC20.transfer version for different ERC-20 implementations.\n    /// Reverts on a failed transfer.\n    /// @param token The address of the ERC-20 token.\n    /// @param to Transfer tokens to.\n    /// @param amount The token amount.\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER, to, amount));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"BoringERC20: Transfer failed\");\n    }\n\n    /// @notice Provides a safe ERC20.transferFrom version for different ERC-20 implementations.\n    /// Reverts on a failed transfer.\n    /// @param token The address of the ERC-20 token.\n    /// @param from Transfer tokens from.\n    /// @param to Transfer tokens to.\n    /// @param amount The token amount.\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER_FROM, from, to, amount));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"BoringERC20: TransferFrom failed\");\n    }\n}"
    },
    "contracts/Utils/Documents.sol": {
      "content": "pragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\n\n/**\n * @title Standard implementation of ERC1643 Document management\n */\ncontract Documents {\n\n    struct Document {\n        uint32 docIndex;    // Store the document name indexes\n        uint64 lastModified; // Timestamp at which document details was last modified\n        string data; // data of the document that exist off-chain\n    }\n\n    // mapping to store the documents details in the document\n    mapping(string => Document) internal _documents;\n    // mapping to store the document name indexes\n    mapping(string => uint32) internal _docIndexes;\n    // Array use to store all the document name present in the contracts\n    string[] _docNames;\n\n    // Document Events\n    event DocumentRemoved(string indexed _name, string _data);\n    event DocumentUpdated(string indexed _name, string _data);\n\n    /**\n     * @notice Used to attach a new document to the contract, or update the data or hash of an existing attached document\n     * @dev Can only be executed by the owner of the contract.\n     * @param _name Name of the document. It should be unique always\n     * @param _data Off-chain data of the document from where it is accessible to investors/advisors to read.\n     */\n    function _setDocument(string calldata _name, string calldata _data) internal {\n        require(bytes(_name).length > 0, \"Zero name is not allowed\");\n        require(bytes(_data).length > 0, \"Should not be a empty data\");\n        // Document storage document = _documents[_name];\n        if (_documents[_name].lastModified == uint64(0)) {\n            _docNames.push(_name);\n            _documents[_name].docIndex = uint32(_docNames.length);\n        }\n        _documents[_name] = Document(_documents[_name].docIndex, uint64(now), _data);\n        emit DocumentUpdated(_name, _data);\n    }\n\n    /**\n     * @notice Used to remove an existing document from the contract by giving the name of the document.\n     * @dev Can only be executed by the owner of the contract.\n     * @param _name Name of the document. It should be unique always\n     */\n\n    function _removeDocument(string calldata _name) internal {\n        require(_documents[_name].lastModified != uint64(0), \"Document should exist\");\n        uint32 index = _documents[_name].docIndex - 1;\n        if (index != _docNames.length - 1) {\n            _docNames[index] = _docNames[_docNames.length - 1];\n            _documents[_docNames[index]].docIndex = index + 1; \n        }\n        _docNames.pop();\n        emit DocumentRemoved(_name, _documents[_name].data);\n        delete _documents[_name];\n    }\n\n    /**\n     * @notice Used to return the details of a document with a known name (`string`).\n     * @param _name Name of the document\n     * @return string The data associated with the document.\n     * @return uint256 the timestamp at which the document was last modified.\n     */\n    function getDocument(string calldata _name) external view returns (string memory, uint256) {\n        return (\n            _documents[_name].data,\n            uint256(_documents[_name].lastModified)\n        );\n    }\n\n    /**\n     * @notice Used to retrieve a full list of documents attached to the smart contract.\n     * @return string List of all documents names present in the contract.\n     */\n    function getAllDocuments() external view returns (string[] memory) {\n        return _docNames;\n    }\n\n    /**\n     * @notice Used to retrieve the total documents in the smart contract.\n     * @return uint256 Count of the document names present in the contract.\n     */\n    function getDocumentCount() external view returns (uint256) {\n        return _docNames.length;\n    }\n\n    /**\n     * @notice Used to retrieve the document name from index in the smart contract.\n     * @return string Name of the document name.\n     */\n    function getDocumentName(uint256 _index) external view returns (string memory) {\n        require(_index < _docNames.length, \"Index out of bounds\");\n        return _docNames[_index];\n    }\n\n}\n"
    },
    "contracts/interfaces/IPointList.sol": {
      "content": "pragma solidity 0.6.12;\n\n// ----------------------------------------------------------------------------\n// White List interface\n// ----------------------------------------------------------------------------\n\ninterface IPointList {\n    function isInList(address account) external view returns (bool);\n    function hasPoints(address account, uint256 amount) external view  returns (bool);\n    function setPoints(\n        address[] memory accounts,\n        uint256[] memory amounts\n    ) external; \n    function initPointList(address accessControl) external ;\n\n}\n"
    },
    "contracts/interfaces/IRewarder.sol": {
      "content": "pragma solidity 0.6.12;\n\nimport \"../Utils/BoringERC20.sol\";\n\ninterface IRewarder {\n    using BoringERC20 for IERC20;\n    function onSushiReward (uint256 pid, address user, uint256 sushiAmount) external;\n    function pendingTokens(uint256 pid, address user, uint256 sushiAmount) external returns (IERC20[] memory , uint256[] memory);\n}"
    },
    "contracts/interfaces/IMasterChef.sol": {
      "content": "pragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\nimport \"../Utils/BoringERC20.sol\";\n\ninterface IMasterChef {\n    using BoringERC20 for IERC20;\n    struct UserInfo {\n        uint256 amount;     // How many LP tokens the user has provided.\n        uint256 rewardDebt; // Reward debt. See explanation below.\n    }\n\n    struct PoolInfo {\n        IERC20 lpToken;           // Address of LP token contract.\n        uint256 allocPoint;       // How many allocation points assigned to this pool. SUSHIs to distribute per block.\n        uint256 lastRewardBlock;  // Last block number that SUSHIs distribution occurs.\n        uint256 accSushiPerShare; // Accumulated SUSHIs per share, times 1e12. See below.\n    }\n\n    function poolInfo(uint256 pid) external view returns (IMasterChef.PoolInfo memory);\n    function totalAllocPoint() external view returns (uint256);\n    function deposit(uint256 _pid, uint256 _amount) external;\n}"
    },
    "contracts/Access/MISOAccessFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.6.12;\n\nimport \"../Utils/CloneFactory.sol\";\nimport \"./MISOAccessControls.sol\";\n\n\ncontract MISOAccessFactory is CloneFactory {\n\n    /// @notice Responsible for access rights to the contract.\n    MISOAccessControls public accessControls;\n\n    /// @notice Address of the template for access controls.\n    address public accessControlTemplate;\n\n    /// @notice Whether initialized or not.\n    bool private initialised;\n\n    /// @notice Minimum fee number.\n    uint256 public minimumFee;\n\n    /// @notice Devs address.\n    address public devaddr;\n\n    /// @notice AccessControls created using the factory.\n    address[] public children;\n\n    /// @notice Tracks if a contract is made by the factory.\n    mapping(address => bool) public isChild;\n\n    /// @notice Event emitted when first initializing Miso AccessControl Factory.\n    event MisoInitAccessFactory(address sender);\n\n    /// @notice Event emitted when a access is created using template id.\n    event AccessControlCreated(address indexed owner,  address accessControls, address admin, address accessTemplate);\n\n    /// @notice Event emitted when a access template is added.\n    event AccessControlTemplateAdded(address oldAccessControl, address newAccessControl);\n\n    /// @notice Event emitted when a access template is removed.\n    event AccessControlTemplateRemoved(address access, uint256 templateId);\n\n    /// @notice Event emitted when a access template is removed.\n    event MinimumFeeUpdated(uint oldFee, uint newFee);\n\n    /// @notice Event emitted when a access template is removed.\n    event DevAddressUpdated(address oldDev, address newDev);\n\n\n    constructor() public {\n    }\n\n    /**\n     * @notice Single gateway to initialize the MISO AccessControl Factory with proper address and set minimum fee.\n     * @dev Can only be initialized once.\n     * @param _minimumFee Minimum fee number.\n     * @param _accessControls Address of the access controls.\n     */\n    function initMISOAccessFactory(uint256 _minimumFee, address _accessControls) external {\n        require(!initialised);\n        initialised = true;\n        minimumFee = _minimumFee;\n        accessControls = MISOAccessControls(_accessControls);\n        emit MisoInitAccessFactory(msg.sender);\n    }\n\n    /// @notice Get the total number of children in the factory.\n    function numberOfChildren() external view returns (uint256) {\n        return children.length;\n    }\n\n    /**\n     * @notice Creates access corresponding to template id.\n     * @dev Initializes access with parameters passed.\n     * @param _admin Address of admin access.\n     */\n    function deployAccessControl(address _admin) external payable returns (address access) {\n        require(msg.value >= minimumFee, \"Minimum fee needs to be paid.\");\n        require(accessControlTemplate != address(0), \"Access control template does not exist\");\n        access = createClone(accessControlTemplate);\n        isChild[address(access)] = true;\n        children.push(address(access));\n        MISOAccessControls(access).initAccessControls(_admin);\n        emit AccessControlCreated(msg.sender, address(access), _admin, accessControlTemplate);\n        if (msg.value > 0) {\n            payable(devaddr).transfer(msg.value);\n        }\n    }\n\n    /**\n     * @notice Function to add new contract templates for the factory.\n     * @dev Should have operator access.\n     * @param _template Template to create new access controls.\n     */\n    function updateAccessTemplate(address _template) external {\n        require(\n            accessControls.hasAdminRole(msg.sender),\n            \"MISOAccessFactory.updateAccessTemplate: Sender must be admin\"\n        );\n        require(_template != address(0));\n        emit AccessControlTemplateAdded(accessControlTemplate, _template);\n        accessControlTemplate = _template;\n    }\n\n    /**\n     * @notice Sets dev address.\n     * @dev Should have operator access.\n     * @param _devaddr Devs address.\n     */\n    function setDev(address _devaddr) external {\n        require(\n            accessControls.hasAdminRole(msg.sender),\n            \"MISOAccessFactory.setMinimumFee: Sender must be admin\"\n        );\n        emit DevAddressUpdated(devaddr, _devaddr);\n        devaddr = _devaddr;\n    }\n\n    /**\n     * @notice Sets minimum fee.\n     * @dev Should have operator access.\n     * @param _minimumFee Minimum fee number.\n     */\n    function setMinimumFee(uint256 _minimumFee) external {\n        require(\n            accessControls.hasAdminRole(msg.sender),\n            \"MISOAccessFactory.setMinimumFee: Sender must be admin\"\n        );\n        emit MinimumFeeUpdated(minimumFee, _minimumFee);\n        minimumFee = _minimumFee;\n    }\n}\n"
    },
    "contracts/Utils/CloneFactory.sol": {
      "content": "pragma solidity 0.6.12;\n\n// ----------------------------------------------------------------------------\n// CloneFactory.sol\n// From\n// https://github.com/optionality/clone-factory/blob/32782f82dfc5a00d103a7e61a17a5dedbd1e8e9d/contracts/CloneFactory.sol\n// ----------------------------------------------------------------------------\n\n/*\nThe MIT License (MIT)\nCopyright (c) 2018 Murray Software, LLC.\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n//solhint-disable max-line-length\n//solhint-disable no-inline-assembly\n\ncontract CloneFactory {\n\n  function createClone(address target) internal returns (address result) {\n    bytes20 targetBytes = bytes20(target);\n    assembly {\n      let clone := mload(0x40)\n      mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n      mstore(add(clone, 0x14), targetBytes)\n      mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n      result := create(0, clone, 0x37)\n    }\n  }\n\n  function isClone(address target, address query) internal view returns (bool result) {\n    bytes20 targetBytes = bytes20(target);\n    assembly {\n      let clone := mload(0x40)\n      mstore(clone, 0x363d3d373d3d3d363d7300000000000000000000000000000000000000000000)\n      mstore(add(clone, 0xa), targetBytes)\n      mstore(add(clone, 0x1e), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n\n      let other := add(clone, 0x40)\n      extcodecopy(query, other, 0, 0x2d)\n      result := and(\n        eq(mload(clone), mload(other)),\n        eq(mload(add(clone, 0xd)), mload(add(other, 0xd)))\n      )\n    }\n  }\n}\n"
    },
    "contracts/OpenZeppelin/utils/Pausable.sol": {
      "content": "\n\npragma solidity 0.6.12;\n\nimport \"./Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor () internal {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "contracts/OpenZeppelin/GSN/Context.sol": {
      "content": "\n\npragma solidity 0.6.12;\n\nimport \"../utils/Context.sol\";\n"
    },
    "contracts/OpenZeppelin/access/Ownable.sol": {
      "content": "\n\npragma solidity 0.6.12;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x00000000d41867734bbee4c6863d9255b2b06ac1"
      }
    }
  }
}